<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flasher Messaging ⚡ - Ultra Secure Communication</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- TailwindCSS -->
<script src="https://cdn.tailwindcss.com"></script>
<script>
function toggleTheme() {
  document.documentElement.classList.toggle("dark");
}
</script>

<style>
body { font-family: sans-serif; transition: background 0.3s, color 0.3s; }
input, textarea { 
  background: white !important; 
  color: black !important; 
  caret-color: black !important; 
}
.dark input, .dark textarea { 
  background: #111 !important; 
  color: white !important; 
  caret-color: white !important; 
}
#lightIndicator {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: #ff0000;
  box-shadow: 0 0 20px #ff0000;
  transition: background 0.2s, box-shadow 0.2s;
}
</style>
</head>

<body class="bg-gray-900 dark:bg-gray-100 text-white dark:text-black min-h-screen flex flex-col items-center p-6 transition-all">

<div class="w-full max-w-2xl flex justify-between items-center mb-6">
  <h1 class="text-3xl font-bold">Flasher Messaging ⚡</h1>
  <button onclick="toggleTheme()" class="px-4 py-2 bg-yellow-500 rounded shadow hover:bg-yellow-600 transition">Toggle Theme</button>
</div>
<p class="text-center text-lg opacity-80 mb-6">Ultra-secure digital communication, works even offline</p>

<!-- Mode Toggle -->
<div class="w-full max-w-2xl bg-gray-800 dark:bg-gray-200 p-4 rounded-xl shadow-xl mb-6 flex justify-between items-center">
  <span class="font-semibold">Mode:</span>
  <div class="flex gap-2">
    <button id="secureModeBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition" onclick="setMode('secure')">Secure Mode</button>
    <button id="offlineModeBtn" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition" onclick="setMode('offline')">Offline Mode</button>
  </div>
</div>

<!-- Communication ID (only for secure mode) -->
<div id="commIdContainer" class="w-full max-w-2xl bg-gray-800 dark:bg-gray-200 p-4 rounded-xl shadow-xl mb-6">
  <label class="block mb-2 text-sm">Communication ID</label>
  <div class="flex gap-2">
    <input id="commId" type="text" placeholder="Enter or generate one..." class="flex-1 p-2 rounded">
    <button onclick="generateSecureID()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">Generate</button>
  </div>
</div>

<!-- Flash Message -->
<div class="w-full max-w-2xl bg-gray-800 dark:bg-gray-200 p-4 rounded-xl shadow-xl mb-6">
  <label class="block mb-2 text-sm">Message to Flash</label>
  <textarea id="flashMessage" placeholder="Type message..." class="w-full h-24 p-2 rounded"></textarea>
  <button onclick="sendFlashMessage()" class="w-full mt-3 py-2 bg-green-600 text-white rounded font-semibold hover:bg-green-700 transition">Send Flash Signal</button>
</div>

<!-- Receive Mode -->
<div class="w-full max-w-2xl bg-gray-800 dark:bg-gray-200 p-4 rounded-xl shadow-xl mb-6">
  <h2 class="font-bold mb-2">Receive Mode</h2>
  <p class="text-sm mb-2 opacity-80">Point your camera at the flashing phone. In Secure Mode, you must enter the Communication ID; Offline Mode works without ID.</p>
  <div class="flex gap-2 mb-3">
    <input id="receiveId" type="text" placeholder="Enter Communication ID to listen for" class="flex-1 p-2 rounded">
    <button onclick="startReceive()" class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition">Start</button>
  </div>
  <div id="receivedOutput" class="p-3 bg-black dark:bg-white text-green-400 dark:text-purple-700 rounded h-24 overflow-y-auto"></div>
</div>

<!-- Camera + Light Detector -->
<div class="w-full max-w-2xl flex flex-col items-center mb-6">
  <video id="video" autoplay playsinline class="w-full rounded-xl shadow-lg"></video>
  <div id="lightIndicator" class="mt-3"></div>
  <p class="mt-2 text-sm text-center opacity-70">Light detector shows green when flash is detected</p>
</div>

<script>
let stream, track;
let receiveActive = false;
let lastBitTime = 0;
let bitBuffer = "";
let binaryBuffer = "";
let mode = "secure"; // secure or offline

function setMode(newMode) {
  mode = newMode;
  document.getElementById("commIdContainer").style.display = mode === "secure" ? "block" : "none";
  document.getElementById("secureModeBtn").classList.toggle("bg-blue-600", mode==="secure");
  document.getElementById("secureModeBtn").classList.toggle("bg-gray-600", mode!=="secure");
  document.getElementById("offlineModeBtn").classList.toggle("bg-blue-600", mode==="offline");
  document.getElementById("offlineModeBtn").classList.toggle("bg-gray-600", mode!=="offline");
}

// Generate random Communication ID
function generateSecureID() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const length = Math.floor(Math.random() * 5) + 6;
  let result = "";
  for (let i = 0; i < length; i++) result += chars[Math.floor(Math.random() * chars.length)];
  document.getElementById("commId").value = result;
}

// Initialize camera
async function initCamera() {
  stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
  const video = document.getElementById("video");
  video.srcObject = stream;
  track = stream.getVideoTracks()[0];
}

// Send flash message
async function sendFlashMessage() {
  const msg = document.getElementById("flashMessage").value.trim();
  if (!msg) return alert("Enter a message first");
  if (!track) await initCamera();

  const caps = track.getCapabilities();
  if (!caps.torch) return alert("Torch not supported on this device.");

  const bitDuration = 150; // ms per bit
  const preamble = "10101011"; // start-of-message

  // Offline mode ignores IDs
  const fullMessage = preamble + [...msg].map(c => c.charCodeAt(0).toString(2).padStart(8,'0')).join("");

  let i = 0;
  function nextBit() {
    if (i >= fullMessage.length) return track.applyConstraints({ advanced: [{ torch: false }] });
    track.applyConstraints({ advanced: [{ torch: fullMessage[i] === "1" }] });
    i++;
    setTimeout(nextBit, bitDuration);
  }
  nextBit();
}

// Receive flashes
async function startReceive() {
  if (!stream) await initCamera();
  receiveActive = true;
  const video = document.getElementById("video");
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const indicator = document.getElementById('lightIndicator');

  const bitDuration = 150; // ms per bit
  const preamble = "10101011";
  let state = "searchPreamble";
  let bitWindow = [];
  let lastBrightness = 0;
  let receivedID = document.getElementById("receiveId").value.trim();

  function readFrame() {
    if (!receiveActive) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);

    const frame = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    let brightness = 0;
    const startX = canvas.width*0.4, endX = canvas.width*0.6;
    const startY = canvas.height*0.4, endY = canvas.height*0.6;
    for(let y=startY|0; y<endY|0; y++) {
      for(let x=startX|0; x<endX|0; x++) {
        const idx = (y*canvas.width + x)*4;
        brightness += frame[idx] + frame[idx+1] + frame[idx+2];
      }
    }
    const pixels = (endX-startX)*(endY-startY);
    brightness /= pixels*3;

    bitWindow.push(brightness);
    if(bitWindow.length > 3) bitWindow.shift();
    const avgBrightness = bitWindow.reduce((a,b)=>a+b,0)/bitWindow.length;

    const bit = avgBrightness > 130 ? "1" : "0";
    const now = performance.now();
    if(now - lastBitTime > bitDuration*0.8) {
      lastBitTime = now;

      // update indicator
      indicator.style.background = bit==="1"?'#00ff00':'#ff0000';
      indicator.style.boxShadow = bit==="1"?'0 0 30px #00ff00':'0 0 20px #ff0000';

      binaryBuffer += bit;

      if(mode==="secure") {
        if(state === "searchPreamble") {
          if(binaryBuffer.endsWith(preamble)) {
            state = "receiveMessage";
            binaryBuffer = "";
          } else if(binaryBuffer.length > preamble.length*2) {
            binaryBuffer = binaryBuffer.slice(-preamble.length);
          }
        } else if(state==="receiveMessage") {
          if(binaryBuffer.length===8) {
            const char = String.fromCharCode(parseInt(binaryBuffer,2));
            document.getElementById("receivedOutput").innerText += char;
            binaryBuffer = "";
          }
        }
      } else { // offline mode
        if(binaryBuffer.length===8) {
          const char = String.fromCharCode(parseInt(binaryBuffer,2));
          document.getElementById("receivedOutput").innerText += char;
          binaryBuffer = "";
        }
      }
    }

    requestAnimationFrame(readFrame);
  }

  readFrame();
}

// Initialize default mode
setMode("secure");
</script>

</body>
</html>
